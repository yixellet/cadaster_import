# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CadasterImport
                                 A QGIS plugin
 Imports XML files from russian state land register
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-02-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Kirill Kotelevsky
        email                : thaid@yandex.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QUrl
from qgis.PyQt.QtGui import QIcon, QDesktopServices
from qgis.PyQt.QtWidgets import QAction
from qgis.utils import iface
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .cadaster_import_dockwidget import CadasterImportDockWidget
from .parser_1 import Parser
import os
from zipfile import ZipFile, is_zipfile
from typing import TextIO, Union

from .cadaster_import_utils import logMessage
from .options_factory import OptionsFactory


class CadasterImport:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CadasterImport_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Russian Cadaster XML Import')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'CadasterImport')
        self.toolbar.setObjectName(u'CadasterImport')

        print("** INITIALIZING CadasterImport")

        self.pluginIsActive = False
        self.dockwidget = None
        self.summary = {}
        self.plugin_path = os.path.dirname(__file__)


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CadasterImport', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/cadaster_import/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Import Cadaster XML'),
            callback=self.run,
            parent=self.iface.mainWindow())
        if self.dockwidget == None:
            # Create the dockwidget (after translation) and keep reference
            self.dockwidget = CadasterImportDockWidget()
            self.dockwidget.analizeButton.clicked.connect(self.analize)
            self.dockwidget.importButton.clicked.connect(self.on_importButton_clicked)
            self.dockwidget.buttonBox.helpRequested.connect(self.showHelp)

    #--------------------------------------------------------------------------
        self.options_factory = OptionsFactory()

        self.options_factory.setTitle(self.tr('Cadaster import'))

        iface.registerOptionsWidgetFactory(self.options_factory)

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING CadasterImport"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD CadasterImport"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Russian Cadaster XML Import'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar
        iface.unregisterOptionsWidgetFactory(self.options_factory)

    #--------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            print("** STARTING CadasterImport")

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = CadasterImportDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

    def on_importButton_clicked(self):
        """Действия при нажатии на кнопку ИМПОРТ
        """
        self.dockwidget.progressBarLabel.setText("Импорт файлов")
        
        if self.dockwidget.selectDirectoryWidget.filePath():
            file_path = self.dockwidget.selectDirectoryWidget.filePath()
            self.dockwidget.progressBar.setRange(0, self.xmlFilesCount)
            self.filesImported = 0
            self.dockwidget.progressBar.setValue(self.filesImported)
            unique_files = []
            for element in self.quarters.values():
                unique_files.append(element['filename'])
            def recursion(dirPath):
                content = os.listdir(dirPath)
                for item in content:
                    self.filesImported += 1
                    path = os.path.join(dirPath, item)
                    if os.path.isfile(path):
                        if os.path.splitext(item)[1] == '.xml' and item in unique_files:
                            # logMessage(item)
                            with open(path, encoding="utf8") as f:
                                p = Parser(f)
                                p.parse()
                            self.dockwidget.progressBar.setValue(self.filesImported)

                    if is_zipfile(path):
                        # logMessage(item)
                        with ZipFile(path, "r") as zip:
                            for f in zip.infolist():
                                if f.filename.split('.')[-1] == 'xml' and f.filename in unique_files:
                                    self.filesImported += 1
                                    # logMessage(str(self.xmlFilesCount) + '-----' + iPath)
                                    with zip.open(f.filename, 'r') as xml_from_zip:
                                        p = Parser(xml_from_zip)
                                        p.parse()
                        self.dockwidget.progressBar.setValue(self.filesImported)
                    if os.path.isdir(path):
                        recursion(path)
                self.dockwidget.progressBar.reset()
                self.dockwidget.progressBar.setValue(0)
            recursion(file_path)
        self.dockwidget.progressBarLabel.setText("")
        self.dockwidget.progressBar.reset()
        self.dockwidget.progressBar.setValue(0)
        self.dockwidget.importButton.setEnabled(False)

    def analize(self):
        """Анализ файлов и определение их содержимого"""
        def whatToDoWithXML(file: TextIO, unique_files: dict,
                            summary: dict, filename: str) -> None:
            """
            Определяет, является ли файл выпиской ЕГРН и, если да, 
            прибавляет на 1 счетчик проанализированных файлов,
            Аргументы:
            file -- XML-файл, являющийся выпиской из ЕГРН
            unique_files -- словарь, хранящий информацию об уникальных
            (не дублирующихся) XML-файлах
            summary -- словарь, хранящий информацию о количестве файлов
            различных типов
            filename -- имя анализируемого файла
            """
            parser = Parser(file)
            type = parser.getFileType()
            if type:
                self.xmlFilesCount += 1
                if type['cadastral_number'] not in unique_files.keys():
                    unique_files[type['cadastral_number']] = \
                    {'date': type['date_formation'], 'filename': filename}
                else:
                    if type['date_formation'] > unique_files[type['cadastral_number']]['date']:
                        unique_files[type['cadastral_number']] = \
                            {'date': type['date_formation'], 'filename': filename}


                if type['tag'] in summary.keys():
                    summary[type['tag']]['count'] += 1
                else:
                    summary[type['tag']] = {'name': type['name'], 'count': 1}

        self.summary = {}
        self.quarters = {}
        self.dockwidget.progressBarLabel.setText("Анализ файлов")
        dirPath = self.dockwidget.selectDirectoryWidget.filePath()
        self.commonElementsCount = len(os.listdir(dirPath))
        self.xmlFilesCount = 0
        self.filesChecked = 0
        self.dockwidget.progressBar.setRange(0, self.commonElementsCount)
        self.dockwidget.progressBar.setValue(self.filesChecked)

        def recursion(dirPath: Union[str, os.PathLike]) -> None:
            """
            Рекурсивно проходит по всем файлам и директориям внутри указанной
            директории, анализирует файлы.
            """
            content = os.listdir(dirPath)
            for i in content:
                iPath = os.path.join(dirPath, i)
                self.filesChecked += 1
                self.dockwidget.progressBar.setValue(self.filesChecked)
                if os.path.isfile(iPath) and os.path.splitext(i)[1] == '.xml':
                    with open(iPath) as file:
                        whatToDoWithXML(file, self.quarters, self.summary, i)
                    self.xmlFilesCount += 1
                    self.quarters[i] = True
                if is_zipfile(iPath):
                    with ZipFile(iPath, "r") as zip:
                        for item in zip.infolist():
                            if item.filename.split('.')[-1] == 'xml':
                                with zip.open(item.filename, 'r') as file:
                                    whatToDoWithXML(file, self.quarters, 
                                                    self.summary, item.filename)
                                self.xmlFilesCount += 1
                                self.quarters[item.filename] = True
                if os.path.isdir(iPath):
                    count = len(os.listdir(iPath))
                    self.commonElementsCount += count
                    self.dockwidget.progressBar.setRange(0, self.commonElementsCount)
                    recursion(iPath)
        
        recursion(dirPath)
        
        typesString = ''
        for filename, _ in self.quarters.items():
            typesString += '<li>{}</li>'.format(filename)
        self.dockwidget.info.setHtml('''
            <p>Обнаружено XML файлов:<span style="font-weight: 700"> {}</span>, из них:</p>
            <ul style="padding: 0">
                {}
            </ul>
            <p>Количество уникальных файлов:<span style="font-weight: 700"> {}</span></p>
        '''.format(self.xmlFilesCount, typesString, len(self.quarters.keys())))
        self.dockwidget.progressBarLabel.setText("")
        self.dockwidget.progressBar.reset()
        self.dockwidget.progressBar.setValue(0)
        self.dockwidget.importButton.setEnabled(True)
                # logMessage(str(self.quarters))

    def showHelp(self):
        help_file = 'file:///%s/help/index.html' % self.plugin_path
        QDesktopServices.openUrl(QUrl(help_file))
